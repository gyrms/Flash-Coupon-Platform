# 프로젝트 개발 가이드 (Project Guide)

> 이 문서는 프로젝트의 **전체 맥락**, **결정 사항**, **개발 로드맵**을 담고 있습니다.  
> 새로운 개발자(또는 AI 어시스턴트)가 프로젝트를 이해하고 이어서 개발할 수 있도록 작성되었습니다.

---

## 📌 프로젝트 배경

### 왜 이 프로젝트를 시작했나?

**목표 회사:**
- **CJ올리브영** (이커머스/유통)
- **카카오페이손해보험** (핀테크/보험)

**지원 직무:**
- 백엔드 개발
- 대용량 트래픽 처리 경험 필요

**핵심 고민:**
> "대용량 트래픽 처리를 혼자서 어떻게 연습할 수 있을까?"

**해결책:**
- 라즈베리파이 5를 로컬 개발/테스트 환경으로 활용
- AWS 프리티어를 실제 배포 환경으로 활용
- 부하 테스트 도구로 대용량 시뮬레이션

---

## 🎯 프로젝트 선택 과정

### 두 회사의 공통점 찾기

**검토한 서비스들:**
1. ✅ **실시간 알림 시스템** - 두 회사 모두 핵심 기능
2. ✅ **선착순 이벤트/쿠폰** - 동시성 제어가 핵심
3. 멤버십/포인트 시스템
4. 개인화 추천 시스템
5. 결제/거래 시스템

**최종 선택:**
```
"선착순 쿠폰 발급 + 실시간 알림" 결합
```

**선택 이유:**
- 두 회사 모두에 어필 가능
- 대용량 트래픽 처리 기법 학습
- MSA 아키텍처 경험
- 동시성 제어 실전 경험
- 실시간 통신 구현
- 4-6주 내 완성 가능

---

## 🔧 기술 스택 결정 과정

### 1단계: 요구사항 정리

**Q: 어떤 서비스로 만들까?**
- A: 범용 이벤트 플랫폼 (업종 제한 없음)
- 이유: 올리브영/카카오페이 모두 적용 가능

**Q: 핵심 기능은?**
- 선착순 쿠폰 발급 (필수)
- 1인당 3개 제한
- 발급 성공/실패 즉시 알림 (필수)
- 회원가입/로그인
- 내 쿠폰함 조회

**Q: 성능 목표는?**
- 처음 제안: 동시 1,000명 (현실적)
- **최종 선택: 동시 10,000명 (도전적)** ⭐
- 이유: 포트폴리오 임팩트, 학습 목표

### 2단계: 기술 스택 선택

**백엔드 - 왜 Java + Node.js 하이브리드?**

**검토한 옵션:**
1. Node.js 단독
2. Java 단독
3. **Java + Node.js 하이브리드** ✅ (선택)

**선택 이유:**
```
쿠폰 발급 (Java Spring Boot):
- 동시성 제어가 핵심
- 트랜잭션 처리 중요
- 대기업 표준 기술
- 금융/유통 업계 선호

실시간 알림 (Node.js):
- 비동기 처리 최적화
- WebSocket 친화적
- 이벤트 기반 아키텍처
- 빠른 실시간 응답

→ MSA 경험 + 실전 아키텍처 어필
```

**프론트엔드 - 왜 React?**
- Vue.js vs React 고민
- React 선택: 취업 시장 수요 더 높음

**데이터베이스 - 왜 PostgreSQL?**
- MySQL vs PostgreSQL 고민
- PostgreSQL 선택: 
  - 트랜잭션 처리 우수
  - JSON 타입 지원
  - 대기업 많이 사용

**캐시/락 - 왜 Redis?**
- 선택지 없었음 (거의 표준)
- 분산 락 구현
- 발급 카운터
- 세션 관리

**메시지 큐 - 왜 RabbitMQ?**
- Kafka vs RabbitMQ 고민
- RabbitMQ 선택:
  - 학습 곡선 낮음
  - 설치/운영 간단
  - 프로젝트 규모에 적합
  - (Phase 3에서 Kafka 검토 가능)

---

## 🏗️ 아키텍처 결정 사항

### MSA 구조를 선택한 이유

**단일 서비스 vs MSA:**
```
단일 서비스 (Monolith):
✅ 개발 빠름
✅ 배포 간단
❌ 확장성 제한
❌ 포트폴리오 임팩트 낮음

MSA:
✅ 서비스별 독립 확장
✅ 기술 스택 다양화
✅ 실전 경험 어필
✅ 장애 격리
❌ 초기 설정 복잡
```

**최종 결정: MSA** ⭐
- 이유: 학습 목표 + 포트폴리오 임팩트

### 동시성 제어 전략

**고민했던 방법들:**
1. DB 락 (비관적 락, 낙관적 락)
2. Redis 분산 락 ✅ (선택)
3. 메시지 큐 순차 처리

**Redis 분산 락을 선택한 이유:**
```
- DB 부하 최소화
- 빠른 응답 속도
- 확장성 좋음
- 업계 표준 패턴
```

**구현 방식:**
```java
1. 발급 요청
2. Redis 락 획득 시도 (5초 타임아웃)
3. Redis에서 재고 감소 (DECR - 원자적 연산)
4. DB에 발급 내역 저장
5. RabbitMQ에 이벤트 발행
6. Redis 락 해제
```

---

## 📅 개발 로드맵

### Phase 1: 핵심 기능 (4주) - 필수

**Week 1-2: 기반 구축**
```
✅ Docker Compose 환경 세팅
  - PostgreSQL
  - Redis
  - RabbitMQ
  - Prometheus + Grafana

✅ 기본 API 구조
  - 회원가입/로그인 (JWT)
  - 기본 CRUD

✅ 프론트엔드 골격
  - React 프로젝트 생성
  - 기본 라우팅
```

**Week 3-4: 핵심 기능**
```
✅ 쿠폰 발급 서비스 (Java)
  - Redis 분산 락 구현
  - 동시성 테스트
  - 발급 API 완성

✅ 실시간 알림 (Node.js)
  - WebSocket 서버
  - RabbitMQ 연동
  - 알림 전송 테스트

✅ 프론트엔드 연동
  - 쿠폰 발급 UI
  - 실시간 알림 수신
```

### Phase 2: 고도화 (2주) - 중요

**Week 5-6:**
```
✅ 부하 테스트
  - JMeter 시나리오 작성
  - 10,000명 동시 접속 테스트
  - 병목 지점 파악 및 개선

✅ 모니터링
  - Prometheus 메트릭 수집
  - Grafana 대시보드 구성
  - Alert 설정

✅ AWS 배포
  - ECS Fargate 또는 EC2
  - RDS, ElastiCache
  - Load Balancer 설정
```

### Phase 3: 확장 기능 (선택)

```
□ 쿠폰 사용/취소
□ 사전 알림 (10분 전)
□ 관리자 대시보드
□ 이벤트 등록 기능
□ 통계 리포트
```

---

## 🎓 학습 목표별 체크리스트

### 기술적 학습 목표

**MSA 아키텍처**
- [ ] 서비스 간 통신 (REST, Message Queue)
- [ ] 서비스 독립 배포
- [ ] API Gateway 패턴
- [ ] 서비스 디스커버리 (선택)

**동시성 제어**
- [ ] Redis 분산 락 구현
- [ ] 원자적 연산 (INCR, DECR)
- [ ] Race Condition 방지
- [ ] 데이터 정합성 보장

**실시간 통신**
- [ ] WebSocket 서버 구현
- [ ] 연결 관리 (재연결, Heartbeat)
- [ ] 브로드캐스트 메시징
- [ ] 상태 동기화

**메시지 큐**
- [ ] RabbitMQ 설치 및 설정
- [ ] Exchange & Queue 설계
- [ ] Producer/Consumer 패턴
- [ ] 메시지 ACK 처리

**성능 최적화**
- [ ] Redis 캐싱 전략
- [ ] DB 쿼리 최적화
- [ ] 인덱스 설계
- [ ] Connection Pool 튜닝

**모니터링**
- [ ] Prometheus 메트릭 수집
- [ ] Grafana 대시보드
- [ ] 로그 중앙화
- [ ] Alert 설정

**부하 테스트**
- [ ] JMeter 시나리오 작성
- [ ] TPS 측정
- [ ] 병목 지점 파악
- [ ] 성능 개선

**인프라**
- [ ] Docker 컨테이너화
- [ ] Docker Compose 오케스트레이션
- [ ] AWS 배포 (ECS, RDS)
- [ ] CI/CD 파이프라인 (선택)

---

## 💡 중요한 의사결정 기록

### 1. 성능 목표를 10,000명으로 설정
**질문:** "너무 높은 거 아닌가요?"
```
답변:
- 라즈베리파이로 실제 10,000명은 불가능
- 하지만 "설계는 10,000명 기준"으로
- 부하 테스트로 병목 지점 파악
- AWS에서 스케일 아웃 검증
- 면접에서 "대용량 고려한 설계" 어필
```

### 2. 1인당 3개 제한
**질문:** "왜 3개?"
```
답변:
- 1개: 너무 제한적
- 무제한: 악용 가능성
- 3개: 적당한 밸런스
- 실제 서비스도 비슷한 정책
```

### 3. 응답 시간 500ms 목표
**질문:** "왜 500ms?"
```
답변:
- 1초 이상: 사용자 체감 느림
- 100ms: 너무 빡빡 (목표 달성 어려움)
- 500ms: 도전적이지만 달성 가능
- 업계 표준 SLA 기준
```

### 4. 쿠폰 1,000개 설정
**질문:** "왜 1,000개?"
```
답변:
- 100개: 너무 빨리 소진 (테스트 어려움)
- 10,000개: 부하 테스트 시간 오래 걸림
- 1,000개: 테스트하기 적당
- 확장 시 개수 조절 가능
```

---

## 🚨 예상 문제와 해결 방안

### 문제 1: 동시성 이슈
**상황:** 여러 사용자가 동시에 마지막 쿠폰 요청
```
해결책:
1. Redis 분산 락으로 순차 처리
2. Redis DECR의 원자성 보장
3. 재시도 로직 추가
4. 에러 핸들링 강화
```

### 문제 2: WebSocket 연결 끊김
**상황:** 네트워크 불안정으로 연결 끊김
```
해결책:
1. 자동 재연결 로직
2. Heartbeat (30초마다 Ping/Pong)
3. 연결 상태 UI 표시
4. Fallback: 폴링으로 대체
```

### 문제 3: DB 병목
**상황:** 발급 내역 저장 시 DB 느림
```
해결책:
1. Redis 캐시 먼저 확인
2. DB 인덱스 최적화
3. Connection Pool 크기 조정
4. 읽기 전용 복제본 추가 (Phase 3)
```

### 문제 4: RabbitMQ 메시지 유실
**상황:** 서버 재시작 시 메시지 손실
```
해결책:
1. Durable Queue 설정
2. Persistent Message
3. Manual ACK 모드
4. Dead Letter Queue 설정
```

### 문제 5: 라즈베리파이 성능 한계
**상황:** 로컬에서 10,000명 테스트 불가
```
해결책:
1. 로컬: 100-1,000명 수준 테스트
2. AWS: 실제 10,000명 테스트
3. 부하 테스트 시나리오 단계별 실행
4. 모니터링으로 예상 성능 추정
```

---

## 📖 다음 Claude에게 전달할 프롬프트

새로운 Claude와 작업을 시작할 때 이렇게 질문하세요:

```
안녕! 나는 "Flash Coupon Platform" 프로젝트를 진행 중이야.

[프로젝트 개요]
- 선착순 쿠폰 발급 + 실시간 알림 시스템
- MSA 구조: Java(쿠폰 서비스) + Node.js(알림 서비스)
- 목표: 동시 10,000명, 응답 500ms 이내
- 목적: CJ올리브영, 카카오페이손해보험 지원용 포트폴리오

[현재 상태]
- 1단계 요구사항 정리 완료
- 문서 작성 완료 (requirements.md, architecture.md, api-spec.md)

[다음 단계]
- 2단계: 상세 설계 및 구현 시작

첨부한 문서들을 읽고, [구체적인 질문]을 도와줘.

예시 질문:
- Redis 분산 락 구현 코드 작성
- Spring Boot 프로젝트 구조 생성
- Docker Compose 테스트
- WebSocket 서버 구현
- 부하 테스트 시나리오 작성
```

---

## 🔑 핵심 개념 정리

### Redis 분산 락이란?
```
여러 서버가 동시에 같은 자원에 접근할 때,
한 번에 하나만 접근하도록 제어하는 방법

예시:
쿠폰 1개 남음 → 10명이 동시에 요청
→ Redis 락으로 순차 처리
→ 1명만 성공, 9명은 "품절" 메시지
```

### WebSocket vs HTTP
```
HTTP (일반적인 방식):
- 클라이언트가 요청 → 서버가 응답
- 실시간 알림 불가능 (폴링 필요)

WebSocket:
- 서버 ↔ 클라이언트 양방향 통신
- 서버가 먼저 알림 보낼 수 있음
- 실시간 알림에 최적
```

### MSA vs Monolith
```
Monolith (단일 서비스):
모든 기능이 하나의 앱

MSA (마이크로서비스):
기능별로 앱을 쪼갬
- 쿠폰 서비스 (Java)
- 알림 서비스 (Node.js)
→ 독립적으로 개발/배포
```

---

## 📚 학습 자료 추천

### 필수 학습
1. **Spring Boot 공식 문서**
   - https://spring.io/guides
   - 특히: REST API, JPA, Redis 연동

2. **Redis 분산 락 패턴**
   - https://redis.io/docs/manual/patterns/distributed-locks/
   - Redlock 알고리즘 이해

3. **Socket.io 문서**
   - https://socket.io/docs/
   - Room, Namespace 개념

4. **RabbitMQ 튜토리얼**
   - https://www.rabbitmq.com/getstarted.html
   - Work Queues, Publish/Subscribe

### 심화 학습
- 대용량 트래픽 처리 기법
- DB 인덱스 최적화
- 캐싱 전략 (Cache-Aside, Write-Through)
- 카오스 엔지니어링

---

## ✅ 체크리스트 (개발 전)

**환경 준비:**
- [ ] 라즈베리파이 5 OS 설치 완료
- [ ] Docker 설치
- [ ] Git 설치
- [ ] Java 17+ 설치
- [ ] Node.js 18+ 설치
- [ ] IDE 설치 (IntelliJ, VSCode)

**학습 준비:**
- [ ] Spring Boot 기본 이해
- [ ] Redis 기본 명령어 학습
- [ ] WebSocket 개념 이해
- [ ] Docker Compose 사용법

**프로젝트 준비:**
- [ ] GitHub 레포지토리 생성
- [ ] 문서 업로드 완료
- [ ] 프로젝트 구조 폴더 생성

---

## 🎯 면접 대비 포인트

### 예상 질문과 답변

**Q: "왜 이 프로젝트를 선택했나요?"**
```
A: 
CJ올리브영과 카카오페이손해보험 두 회사의 공통점을 분석했습니다.
두 회사 모두 대용량 트래픽 처리와 실시간 알림이 핵심이었고,
선착순 이벤트는 이커머스와 금융 모두에서 중요한 기능이라 판단했습니다.
특히 동시성 제어와 실시간 통신을 함께 경험할 수 있어 선택했습니다.
```

**Q: "왜 MSA 구조를 선택했나요?"**
```
A:
쿠폰 발급은 트랜잭션과 동시성 제어가 중요해서 Java를,
실시간 알림은 비동기 처리가 중요해서 Node.js를 선택했습니다.
각 서비스의 특성에 맞는 기술을 선택하고,
독립적으로 확장 가능한 구조를 만들고 싶었습니다.
```

**Q: "10,000명 동시 접속을 어떻게 처리했나요?"**
```
A:
1. Redis 분산 락으로 동시성 제어
2. Redis 캐싱으로 DB 부하 감소
3. 메시지 큐로 비동기 처리
4. JMeter로 부하 테스트 및 병목 지점 파악
5. AWS에서 Auto Scaling 테스트

실제 결과: [테스트 결과 수치]
```

**Q: "어려웠던 점과 해결 방법은?"**
```
A:
가장 어려웠던 건 동시성 제어였습니다.
처음엔 DB 락을 사용했는데 성능이 나오지 않았고,
Redis 분산 락으로 바꾸면서 응답 시간을 70% 개선했습니다.
또한 락 타임아웃 설정과 재시도 로직을 통해
안정성도 확보했습니다.
```

---

## 📞 트러블슈팅 가이드

### 로컬 개발 환경 문제

**문제: Docker 컨테이너가 안 뜨는 경우**
```bash
# 포트 충돌 확인
sudo lsof -i :5432  # PostgreSQL
sudo lsof -i :6379  # Redis
sudo lsof -i :5672  # RabbitMQ

# 컨테이너 로그 확인
docker-compose logs postgres
docker-compose logs redis

# 재시작
docker-compose down -v
docker-compose up -d
```

**문제: Redis 연결 안 되는 경우**
```bash
# Redis CLI 접속 테스트
redis-cli ping
# 응답: PONG

# Spring Boot에서 연결 테스트
curl http://localhost:8080/actuator/health
```

**문제: RabbitMQ 메시지 안 오는 경우**
```bash
# RabbitMQ Management UI 접속
# http://localhost:15672
# ID: admin, PW: admin123

# Queue 확인
# Consumer가 연결되어 있는지 확인
# Message rate 확인
```

---

## 🎓 추가 개선 아이디어 (Phase 4+)

나중에 더 발전시킬 수 있는 아이디어들:

1. **블루-그린 배포**
   - 무중단 배포 구현
   - Kubernetes 마이그레이션

2. **A/B 테스트**
   - 쿠폰 UI 두 버전 테스트
   - 전환율 측정

3. **머신러닝 추천**
   - 사용자 행동 기반 쿠폰 추천
   - 참여 가능성 예측

4. **글로벌 서비스**
   - 다국어 지원
   - 시간대 처리
   - CDN 적용

5. **모바일 앱**
   - Flutter 또는 React Native
   - 푸시 알림 (FCM)

---

**문서 버전:** 1.0  
**최종 수정일:** 2026-02-11  
**작성자:** gyrms

**이 문서를 새로운 Claude에게 보여주면:**
- 프로젝트의 전체 맥락을 이해할 수 있습니다
- 왜 이런 결정을 내렸는지 알 수 있습니다
- 다음에 무엇을 해야 할지 명확합니다
- 예상되는 문제와 해결책을 알고 있습니다

**시작 프롬프트 예시:**
```
이 프로젝트 가이드(project-guide.md)와 다른 문서들(requirements.md, 
architecture.md, api-spec.md)을 읽고, [원하는 작업]을 도와줘.
```
